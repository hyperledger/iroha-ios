// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Commands.pbobjc.h"
 #import "Primitive.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - CommandsRoot

@implementation CommandsRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - CommandsRoot_FileDescriptor

static GPBFileDescriptor *CommandsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iroha.protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AddAssetQuantity

@implementation AddAssetQuantity

@dynamic assetId;
@dynamic amount;

typedef struct AddAssetQuantity__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *amount;
} AddAssetQuantity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = AddAssetQuantity_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddAssetQuantity__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AddAssetQuantity_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddAssetQuantity__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddAssetQuantity class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddAssetQuantity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddPeer

@implementation AddPeer

@dynamic hasPeer, peer;

typedef struct AddPeer__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} AddPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = AddPeer_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddPeer__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddPeer class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddPeer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddSignatory

@implementation AddSignatory

@dynamic accountId;
@dynamic publicKey;

typedef struct AddSignatory__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *publicKey;
} AddSignatory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AddSignatory_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddSignatory__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = AddSignatory_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddSignatory__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddSignatory class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddSignatory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAsset

@implementation CreateAsset

@dynamic assetName;
@dynamic domainId;
@dynamic precision;

typedef struct CreateAsset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t precision;
  NSString *assetName;
  NSString *domainId;
} CreateAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetName",
        .dataTypeSpecific.className = NULL,
        .number = CreateAsset_FieldNumber_AssetName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, assetName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = CreateAsset_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "precision",
        .dataTypeSpecific.className = NULL,
        .number = CreateAsset_FieldNumber_Precision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, precision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAsset class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAccount

@implementation CreateAccount

@dynamic accountName;
@dynamic domainId;
@dynamic publicKey;

typedef struct CreateAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountName;
  NSString *domainId;
  NSString *publicKey;
} CreateAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = NULL,
        .number = CreateAccount_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = CreateAccount_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = CreateAccount_FieldNumber_PublicKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAccount class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAccountDetail

@implementation SetAccountDetail

@dynamic accountId;
@dynamic key;
@dynamic value;

typedef struct SetAccountDetail__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *key;
  NSString *value;
} SetAccountDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = SetAccountDetail_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = SetAccountDetail_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = SetAccountDetail_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAccountDetail class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAccountDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateDomain

@implementation CreateDomain

@dynamic domainId;
@dynamic defaultRole;

typedef struct CreateDomain__storage_ {
  uint32_t _has_storage_[1];
  NSString *domainId;
  NSString *defaultRole;
} CreateDomain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = CreateDomain_FieldNumber_DomainId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateDomain__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "defaultRole",
        .dataTypeSpecific.className = NULL,
        .number = CreateDomain_FieldNumber_DefaultRole,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateDomain__storage_, defaultRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateDomain class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateDomain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveSignatory

@implementation RemoveSignatory

@dynamic accountId;
@dynamic publicKey;

typedef struct RemoveSignatory__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *publicKey;
} RemoveSignatory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = RemoveSignatory_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveSignatory__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = RemoveSignatory_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveSignatory__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveSignatory class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveSignatory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAccountQuorum

@implementation SetAccountQuorum

@dynamic accountId;
@dynamic quorum;

typedef struct SetAccountQuorum__storage_ {
  uint32_t _has_storage_[1];
  uint32_t quorum;
  NSString *accountId;
} SetAccountQuorum__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = SetAccountQuorum_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAccountQuorum__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quorum",
        .dataTypeSpecific.className = NULL,
        .number = SetAccountQuorum_FieldNumber_Quorum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAccountQuorum__storage_, quorum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAccountQuorum class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAccountQuorum__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferAsset

@implementation TransferAsset

@dynamic srcAccountId;
@dynamic destAccountId;
@dynamic assetId;
@dynamic description_p;
@dynamic amount;

typedef struct TransferAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *srcAccountId;
  NSString *destAccountId;
  NSString *assetId;
  NSString *description_p;
  NSString *amount;
} TransferAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "srcAccountId",
        .dataTypeSpecific.className = NULL,
        .number = TransferAsset_FieldNumber_SrcAccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, srcAccountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "destAccountId",
        .dataTypeSpecific.className = NULL,
        .number = TransferAsset_FieldNumber_DestAccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, destAccountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = TransferAsset_FieldNumber_AssetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = TransferAsset_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TransferAsset_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferAsset class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppendRole

@implementation AppendRole

@dynamic accountId;
@dynamic roleName;

typedef struct AppendRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *roleName;
} AppendRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AppendRole_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppendRole__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roleName",
        .dataTypeSpecific.className = NULL,
        .number = AppendRole_FieldNumber_RoleName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppendRole__storage_, roleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppendRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppendRole__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetachRole

@implementation DetachRole

@dynamic accountId;
@dynamic roleName;

typedef struct DetachRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *roleName;
} DetachRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = DetachRole_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetachRole__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roleName",
        .dataTypeSpecific.className = NULL,
        .number = DetachRole_FieldNumber_RoleName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetachRole__storage_, roleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetachRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetachRole__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateRole

@implementation CreateRole

@dynamic roleName;
@dynamic permissionsArray, permissionsArray_Count;

typedef struct CreateRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *roleName;
  GPBEnumArray *permissionsArray;
} CreateRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roleName",
        .dataTypeSpecific.className = NULL,
        .number = CreateRole_FieldNumber_RoleName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateRole__storage_, roleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = RolePermission_EnumDescriptor,
        .number = CreateRole_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateRole__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRole__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GrantPermission

@implementation GrantPermission

@dynamic accountId;
@dynamic permission;

typedef struct GrantPermission__storage_ {
  uint32_t _has_storage_[1];
  GrantablePermission permission;
  NSString *accountId;
} GrantPermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = GrantPermission_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GrantPermission__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permission",
        .dataTypeSpecific.enumDescFunc = GrantablePermission_EnumDescriptor,
        .number = GrantPermission_FieldNumber_Permission,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GrantPermission__storage_, permission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GrantPermission class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GrantPermission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GrantPermission_Permission_RawValue(GrantPermission *message) {
  GPBDescriptor *descriptor = [GrantPermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GrantPermission_FieldNumber_Permission];
  return GPBGetMessageInt32Field(message, field);
}

void SetGrantPermission_Permission_RawValue(GrantPermission *message, int32_t value) {
  GPBDescriptor *descriptor = [GrantPermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GrantPermission_FieldNumber_Permission];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RevokePermission

@implementation RevokePermission

@dynamic accountId;
@dynamic permission;

typedef struct RevokePermission__storage_ {
  uint32_t _has_storage_[1];
  GrantablePermission permission;
  NSString *accountId;
} RevokePermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = RevokePermission_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RevokePermission__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permission",
        .dataTypeSpecific.enumDescFunc = GrantablePermission_EnumDescriptor,
        .number = RevokePermission_FieldNumber_Permission,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RevokePermission__storage_, permission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RevokePermission class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RevokePermission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RevokePermission_Permission_RawValue(RevokePermission *message) {
  GPBDescriptor *descriptor = [RevokePermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RevokePermission_FieldNumber_Permission];
  return GPBGetMessageInt32Field(message, field);
}

void SetRevokePermission_Permission_RawValue(RevokePermission *message, int32_t value) {
  GPBDescriptor *descriptor = [RevokePermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RevokePermission_FieldNumber_Permission];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SubtractAssetQuantity

@implementation SubtractAssetQuantity

@dynamic assetId;
@dynamic amount;

typedef struct SubtractAssetQuantity__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *amount;
} SubtractAssetQuantity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = SubtractAssetQuantity_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SubtractAssetQuantity__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SubtractAssetQuantity_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SubtractAssetQuantity__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubtractAssetQuantity class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubtractAssetQuantity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Command

@implementation Command

@dynamic commandOneOfCase;
@dynamic addAssetQuantity;
@dynamic addPeer;
@dynamic addSignatory;
@dynamic appendRole;
@dynamic createAccount;
@dynamic createAsset;
@dynamic createDomain;
@dynamic createRole;
@dynamic detachRole;
@dynamic grantPermission;
@dynamic removeSignatory;
@dynamic revokePermission;
@dynamic setAccountDetail;
@dynamic setAccountQuorum;
@dynamic subtractAssetQuantity;
@dynamic transferAsset;

typedef struct Command__storage_ {
  uint32_t _has_storage_[2];
  AddAssetQuantity *addAssetQuantity;
  AddPeer *addPeer;
  AddSignatory *addSignatory;
  AppendRole *appendRole;
  CreateAccount *createAccount;
  CreateAsset *createAsset;
  CreateDomain *createDomain;
  CreateRole *createRole;
  DetachRole *detachRole;
  GrantPermission *grantPermission;
  RemoveSignatory *removeSignatory;
  RevokePermission *revokePermission;
  SetAccountDetail *setAccountDetail;
  SetAccountQuorum *setAccountQuorum;
  SubtractAssetQuantity *subtractAssetQuantity;
  TransferAsset *transferAsset;
} Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addAssetQuantity",
        .dataTypeSpecific.className = GPBStringifySymbol(AddAssetQuantity),
        .number = Command_FieldNumber_AddAssetQuantity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addAssetQuantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addPeer",
        .dataTypeSpecific.className = GPBStringifySymbol(AddPeer),
        .number = Command_FieldNumber_AddPeer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addSignatory",
        .dataTypeSpecific.className = GPBStringifySymbol(AddSignatory),
        .number = Command_FieldNumber_AddSignatory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addSignatory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appendRole",
        .dataTypeSpecific.className = GPBStringifySymbol(AppendRole),
        .number = Command_FieldNumber_AppendRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, appendRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(CreateAccount),
        .number = Command_FieldNumber_CreateAccount,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createAsset",
        .dataTypeSpecific.className = GPBStringifySymbol(CreateAsset),
        .number = Command_FieldNumber_CreateAsset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createDomain",
        .dataTypeSpecific.className = GPBStringifySymbol(CreateDomain),
        .number = Command_FieldNumber_CreateDomain,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createDomain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createRole",
        .dataTypeSpecific.className = GPBStringifySymbol(CreateRole),
        .number = Command_FieldNumber_CreateRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detachRole",
        .dataTypeSpecific.className = GPBStringifySymbol(DetachRole),
        .number = Command_FieldNumber_DetachRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, detachRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "grantPermission",
        .dataTypeSpecific.className = GPBStringifySymbol(GrantPermission),
        .number = Command_FieldNumber_GrantPermission,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, grantPermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeSignatory",
        .dataTypeSpecific.className = GPBStringifySymbol(RemoveSignatory),
        .number = Command_FieldNumber_RemoveSignatory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, removeSignatory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revokePermission",
        .dataTypeSpecific.className = GPBStringifySymbol(RevokePermission),
        .number = Command_FieldNumber_RevokePermission,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, revokePermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAccountDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(SetAccountDetail),
        .number = Command_FieldNumber_SetAccountDetail,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, setAccountDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAccountQuorum",
        .dataTypeSpecific.className = GPBStringifySymbol(SetAccountQuorum),
        .number = Command_FieldNumber_SetAccountQuorum,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, setAccountQuorum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subtractAssetQuantity",
        .dataTypeSpecific.className = GPBStringifySymbol(SubtractAssetQuantity),
        .number = Command_FieldNumber_SubtractAssetQuantity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, subtractAssetQuantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transferAsset",
        .dataTypeSpecific.className = GPBStringifySymbol(TransferAsset),
        .number = Command_FieldNumber_TransferAsset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, transferAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Command class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Command__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "command",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Command_ClearCommandOneOfCase(Command *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
