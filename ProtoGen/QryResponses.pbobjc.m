// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qry_responses.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "QryResponses.pbobjc.h"
 #import "Block.pbobjc.h"
 #import "Transaction.pbobjc.h"
 #import "Primitive.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - QryResponsesRoot

@implementation QryResponsesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - QryResponsesRoot_FileDescriptor

static GPBFileDescriptor *QryResponsesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iroha.protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Asset

@implementation Asset

@dynamic assetId;
@dynamic domainId;
@dynamic precision;

typedef struct Asset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t precision;
  NSString *assetId;
  NSString *domainId;
} Asset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = Asset_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Asset__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = Asset_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Asset__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "precision",
        .dataTypeSpecific.className = NULL,
        .number = Asset_FieldNumber_Precision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Asset__storage_, precision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Asset class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Asset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Domain

@implementation Domain

@dynamic domainId;
@dynamic defaultRole;

typedef struct Domain__storage_ {
  uint32_t _has_storage_[1];
  NSString *domainId;
  NSString *defaultRole;
} Domain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = Domain_FieldNumber_DomainId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Domain__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "defaultRole",
        .dataTypeSpecific.className = NULL,
        .number = Domain_FieldNumber_DefaultRole,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Domain__storage_, defaultRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Domain class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Domain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account

@implementation Account

@dynamic accountId;
@dynamic domainId;
@dynamic quorum;
@dynamic jsonData;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  uint32_t quorum;
  NSString *accountId;
  NSString *domainId;
  NSString *jsonData;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, domainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quorum",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Quorum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, quorum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "jsonData",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_JsonData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, jsonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountAsset

@implementation AccountAsset

@dynamic assetId;
@dynamic accountId;
@dynamic balance;

typedef struct AccountAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *accountId;
  NSString *balance;
} AccountAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = AccountAsset_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = AccountAsset_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = AccountAsset_FieldNumber_Balance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountAsset class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountAssetResponse

@implementation AccountAssetResponse

@dynamic accountAssetsArray, accountAssetsArray_Count;

typedef struct AccountAssetResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *accountAssetsArray;
} AccountAssetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountAssetsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountAsset),
        .number = AccountAssetResponse_FieldNumber_AccountAssetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountAssetResponse__storage_, accountAssetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountAssetResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountAssetResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountDetailResponse

@implementation AccountDetailResponse

@dynamic detail;

typedef struct AccountDetailResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *detail;
} AccountDetailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetailResponse_FieldNumber_Detail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountDetailResponse__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountDetailResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountDetailResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountResponse

@implementation AccountResponse

@dynamic hasAccount, account;
@dynamic accountRolesArray, accountRolesArray_Count;

typedef struct AccountResponse__storage_ {
  uint32_t _has_storage_[1];
  Account *account;
  NSMutableArray *accountRolesArray;
} AccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(Account),
        .number = AccountResponse_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountRolesArray",
        .dataTypeSpecific.className = NULL,
        .number = AccountResponse_FieldNumber_AccountRolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, accountRolesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetResponse

@implementation AssetResponse

@dynamic hasAsset, asset;

typedef struct AssetResponse__storage_ {
  uint32_t _has_storage_[1];
  Asset *asset;
} AssetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "asset",
        .dataTypeSpecific.className = GPBStringifySymbol(Asset),
        .number = AssetResponse_FieldNumber_Asset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetResponse__storage_, asset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RolesResponse

@implementation RolesResponse

@dynamic rolesArray, rolesArray_Count;

typedef struct RolesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rolesArray;
} RolesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rolesArray",
        .dataTypeSpecific.className = NULL,
        .number = RolesResponse_FieldNumber_RolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RolesResponse__storage_, rolesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RolesResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RolesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RolePermissionsResponse

@implementation RolePermissionsResponse

@dynamic permissionsArray, permissionsArray_Count;

typedef struct RolePermissionsResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *permissionsArray;
} RolePermissionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = RolePermission_EnumDescriptor,
        .number = RolePermissionsResponse_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RolePermissionsResponse__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RolePermissionsResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RolePermissionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ErrorResponse

@implementation ErrorResponse

@dynamic reason;
@dynamic message;
@dynamic errorCode;

typedef struct ErrorResponse__storage_ {
  uint32_t _has_storage_[1];
  ErrorResponse_Reason reason;
  uint32_t errorCode;
  NSString *message;
} ErrorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ErrorResponse_Reason_EnumDescriptor,
        .number = ErrorResponse_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ErrorResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = ErrorResponse_FieldNumber_ErrorCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ErrorResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ErrorResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ErrorResponse_Reason_RawValue(ErrorResponse *message) {
  GPBDescriptor *descriptor = [ErrorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorResponse_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetErrorResponse_Reason_RawValue(ErrorResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ErrorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorResponse_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ErrorResponse_Reason

GPBEnumDescriptor *ErrorResponse_Reason_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StatelessInvalid\000StatefulInvalid\000NoAccou"
        "nt\000NoAccountAssets\000NoAccountDetail\000NoSig"
        "natories\000NotSupported\000NoAsset\000NoRoles\000";
    static const int32_t values[] = {
        ErrorResponse_Reason_StatelessInvalid,
        ErrorResponse_Reason_StatefulInvalid,
        ErrorResponse_Reason_NoAccount,
        ErrorResponse_Reason_NoAccountAssets,
        ErrorResponse_Reason_NoAccountDetail,
        ErrorResponse_Reason_NoSignatories,
        ErrorResponse_Reason_NotSupported,
        ErrorResponse_Reason_NoAsset,
        ErrorResponse_Reason_NoRoles,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ErrorResponse_Reason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ErrorResponse_Reason_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ErrorResponse_Reason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ErrorResponse_Reason_StatelessInvalid:
    case ErrorResponse_Reason_StatefulInvalid:
    case ErrorResponse_Reason_NoAccount:
    case ErrorResponse_Reason_NoAccountAssets:
    case ErrorResponse_Reason_NoAccountDetail:
    case ErrorResponse_Reason_NoSignatories:
    case ErrorResponse_Reason_NotSupported:
    case ErrorResponse_Reason_NoAsset:
    case ErrorResponse_Reason_NoRoles:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SignatoriesResponse

@implementation SignatoriesResponse

@dynamic keysArray, keysArray_Count;

typedef struct SignatoriesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysArray;
} SignatoriesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .dataTypeSpecific.className = NULL,
        .number = SignatoriesResponse_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignatoriesResponse__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignatoriesResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignatoriesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionsResponse

@implementation TransactionsResponse

@dynamic transactionsArray, transactionsArray_Count;

typedef struct TransactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} TransactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionsResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionsResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionsResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionsPageResponse

@implementation TransactionsPageResponse

@dynamic nextPageTagOneOfCase;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic allTransactionsSize;
@dynamic nextTxHash;

typedef struct TransactionsPageResponse__storage_ {
  uint32_t _has_storage_[2];
  uint32_t allTransactionsSize;
  NSMutableArray *transactionsArray;
  NSString *nextTxHash;
} TransactionsPageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionsPageResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allTransactionsSize",
        .dataTypeSpecific.className = NULL,
        .number = TransactionsPageResponse_FieldNumber_AllTransactionsSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, allTransactionsSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nextTxHash",
        .dataTypeSpecific.className = NULL,
        .number = TransactionsPageResponse_FieldNumber_NextTxHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, nextTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionsPageResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionsPageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "nextPageTag",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TransactionsPageResponse_ClearNextPageTagOneOfCase(TransactionsPageResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - QueryResponse

@implementation QueryResponse

@dynamic responseOneOfCase;
@dynamic accountAssetsResponse;
@dynamic accountDetailResponse;
@dynamic accountResponse;
@dynamic errorResponse;
@dynamic signatoriesResponse;
@dynamic transactionsResponse;
@dynamic assetResponse;
@dynamic rolesResponse;
@dynamic rolePermissionsResponse;
@dynamic transactionsPageResponse;
@dynamic queryHash;

typedef struct QueryResponse__storage_ {
  uint32_t _has_storage_[2];
  AccountAssetResponse *accountAssetsResponse;
  AccountDetailResponse *accountDetailResponse;
  AccountResponse *accountResponse;
  ErrorResponse *errorResponse;
  SignatoriesResponse *signatoriesResponse;
  TransactionsResponse *transactionsResponse;
  AssetResponse *assetResponse;
  RolesResponse *rolesResponse;
  RolePermissionsResponse *rolePermissionsResponse;
  NSString *queryHash;
  TransactionsPageResponse *transactionsPageResponse;
} QueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountAssetsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountAssetResponse),
        .number = QueryResponse_FieldNumber_AccountAssetsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountAssetsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountDetailResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountDetailResponse),
        .number = QueryResponse_FieldNumber_AccountDetailResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountDetailResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountResponse),
        .number = QueryResponse_FieldNumber_AccountResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ErrorResponse),
        .number = QueryResponse_FieldNumber_ErrorResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, errorResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatoriesResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(SignatoriesResponse),
        .number = QueryResponse_FieldNumber_SignatoriesResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, signatoriesResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionsResponse),
        .number = QueryResponse_FieldNumber_TransactionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, transactionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetResponse),
        .number = QueryResponse_FieldNumber_AssetResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, assetResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rolesResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(RolesResponse),
        .number = QueryResponse_FieldNumber_RolesResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, rolesResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rolePermissionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(RolePermissionsResponse),
        .number = QueryResponse_FieldNumber_RolePermissionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, rolePermissionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryHash",
        .dataTypeSpecific.className = NULL,
        .number = QueryResponse_FieldNumber_QueryHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, queryHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionsPageResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionsPageResponse),
        .number = QueryResponse_FieldNumber_TransactionsPageResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, transactionsPageResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void QueryResponse_ClearResponseOneOfCase(QueryResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - BlockResponse

@implementation BlockResponse

@dynamic hasBlock, block;

typedef struct BlockResponse__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} BlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = BlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockErrorResponse

@implementation BlockErrorResponse

@dynamic message;

typedef struct BlockErrorResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} BlockErrorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = BlockErrorResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockErrorResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockErrorResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockErrorResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockQueryResponse

@implementation BlockQueryResponse

@dynamic responseOneOfCase;
@dynamic blockResponse;
@dynamic blockErrorResponse;

typedef struct BlockQueryResponse__storage_ {
  uint32_t _has_storage_[2];
  BlockResponse *blockResponse;
  BlockErrorResponse *blockErrorResponse;
} BlockQueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockResponse),
        .number = BlockQueryResponse_FieldNumber_BlockResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockQueryResponse__storage_, blockResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockErrorResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockErrorResponse),
        .number = BlockQueryResponse_FieldNumber_BlockErrorResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockQueryResponse__storage_, blockErrorResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockQueryResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockQueryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void BlockQueryResponse_ClearResponseOneOfCase(BlockQueryResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
